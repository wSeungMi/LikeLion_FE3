// 스코프 : 변수의 유효범위(생존범위)
// 전역 스코프, 함수 스코프, 블록 스코프(ES6에 생김)가 존함

// 전역 스코프는 어디서든 접근할 수 있기때문에 사용이 쉽지만 타인과의 협업이나 라이브러리 사용시 충돌의 가능성이 있다.
// 메모리 사용면에 있어서도 좋지 않다. 전역에 선언된 변수는 프로그램이 끝날 때까지 메모리를 점유한다.

// 블록 스코프: 변수의 생존 범위가 {} 블록 안에서 끝나는 것

// 전역 스코프: 자바스크립트 어디에서든 접근이 다 가능!
// let val = 1;
// console.log(val);

// 함수 스코프: 함수 안에서만 유효함
// function test() {
//     // let val2 = 1;
//     let a = 1;
//     let b = 2;
//     return a + b;
// }

// console.log(val2); // 함수 안에서 선언된 변수는 외부(전역공간)에서 접근 X

// console.log(test());

// let a = 20; // 함수 안에 있는 a랑 전혀 연관이 없다! 별개의 변수임

// console.log(test()); // 함수를 뒤에 출력해도 아무런 변화가 없음~

// 함수 안에 정의된 변수는 외부에서는 접근할 수 없지만 (함수스코프가 존재해서)
// 함수 안에서 정의된 변수는 함수안에서는 어디든 접근이 가능하다
// 계속 외부 스코프를 타고가면서 우리가 원하는 데이터/어떤 변수가 있는지 확인하는 것(함수 스코프 내에 없으면 전역까지 찾아감, 그랬는데도 없으면 그때서야 에러가 나게됨 => 함수 스코프체이닝)

let a = 1; // 그래서 이렇게 전역에 변수를 선언해도 스코프체이닝을 통해 찾아내는 것!
const myFunc = function () {
    g = 10; // 이렇게 키워드 없이 선언하면 무조건 전역변수로 선언됨!!
    // let a = 1;
    let b = 2;

    const myFunc2 = function () {
        let b = 5;
        let c = 6;

        a = a + b + c;
        console.log(a);
    };

    myFunc2();
};

myFunc();
console.log(g); // 그래서 외부에서도 함수 안에 있는 변수인데도 접근이 가능함!
